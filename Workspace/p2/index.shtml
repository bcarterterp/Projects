<!--#include virtual="header.html" -->

<h1 class="title">Project 2 - C-- : Type Checker & AST</h1>
<center>
Due 11:59pm Wed, March 26th, 2014<br>
</center>

<p>
<h2>Introduction</h2>

<p>
In this project you will add syntax-directed translation
to your C-- parser in order to build symbol tables,
perform type checking, and construct an abstract syntax
tree (AST) intermediate representation of the input program.

<p>
<h2>Getting Started</h2>

Project 2 will be implemented in Java in Eclipse. 
Download the following file:

<ul>
<li> Eclipse project archive file <a href="p2.zip">p2.zip</a>
</ul>

You can import the project into Eclipse as an existing project 
in an archive file. 

<h3>Changes</h3>
<p>
See project 1 <a href="../p1">description</a> for description of project
files and syntax/semantics of C--.  Compared to project 1, there have been 
a few changes to mycc.cup:

<ul>
<li> Added a number of actions to build basic symbol table & AST.
<li> Uncommented calls for building AST and classFile in header.  
</ul>

There are also a number of files that have been added/modified since
project 1.  For this project, you should replace the 
skeleton mycc.lex file with your mycc.lex
file from project 1.  You should compare the skeleton mycc.cup
file with your mycc.cup file from project 1 and integrate the
changes.  For all other files, use the version from project 2.
<p>

<p>
</p><h2>Requirements</h2>

<p>
Assuming you passed all the test cases for project 1 (minus error checking),
the only changes you need to make for project 2 should be to 
add/modify action routines in mycc.cup.
<p>
You may assume that all input C-- programs in the test cases
are syntactically correct.
<p>

<h3>
Symbol Tables
</h3>

Symbol tables are used to collect and store information 
on all identifiers (variables, functions) in the program.
A variable can be local, global, or passed as a parameter. 
To support nested lexical scoping, you must link together 
multiple symbol tables in a hierarchical manner.
Use the symTab and symTabEntry classes to construct 
symbol tables in the C-- compiler.  Each nested scope must
have its own symbol table.  References to symbol tables for 
each function are stored in its symTabEntry. 

<p>
Goals: 
<ul>
<li> Build a symbol table for each lexical scope
<li> Link up symbol tables appropriately
<ul>
<li> Functions and global variables in top-level symbol table
<li> Symbol table for function in its symTabEntry
<li> Symbol tables for local scopes in program order (order seen in program text)
</ul>
<li> Have your symbol tables print out in the manner expected in the test*.out files
</ul>

<h3>
Abstract Syntax Tree
</h3>

An abstract syntax tree (AST) is an intermediate representation
of a program.  It can be constructed during a bottom-up parse.
Use the expNode, astNode, and astNodeList classes to construct
ASTs in the C-- compiler.

<p>
You may assume ASTs will be examined only for C-- programs
with no type errors. 

<p>
Goals: 
<ul>
<li> Build the AST for the input program
<li> Have your AST print out in the manner expected in the test*.out files
</ul>

<h3>
Type Checker
</h3>

The type checker makes sure that all variables accessed are 
legally declared and have proper types.  It also provides 
warning of undeclared and redeclared variables.
Use information from symbol tables to perform type 
checking in the C-- compiler.
<p>
Most type errors are straightforward.  One tricky case in C-- is 
handling type errors for the "==" and "!=" operators, which can
take either two integer operands, or two boolean operands.  
If types of the two operands differ, assume the type of the 
first operand is the intended type (i.e., "if (a < b) == 2" would
assume "2" should be a boolean, while "if (2 == (a < b)" would
assume "a < b" should be an integer.
<p>
If the forward declaration for a function does not match
the actual function definition, go with the function
definition once it is compiled.
<p>

Goals: 
<ul>
<li> Report the following type errors using parser.msg():
<ul>
<li> "undeclared variable <i>x</i>" // <indent>x is used before it is declared</indent>
<li> "redeclaration of <i>x</i>"  // x is declared more than once in same scope
<li> "requires integer"  // for operators such as + * < ...
<li> "requires boolean"  // for operators such as &&, ||, IF, WHILE
<li> "misuse of <i>x</i>"  // misuse x[i], x(i), x
<li> "illegal subscript"  // non-integer array subscript
<li> "parameter mismatch"  // e.g., declared as void foo(int x), invoked as foo()
<li> "return mismatch"  // return type different from function declaration
<li> "forward decl mismatch <i>x</i>"  // mismatched return type or parameter
</ul>
</ul>

<p>

<h2>Main Classes</h2>

<h3> parser </h3>

Generated by CUP, this is the class which performs the actual
parse.  All action code in your CUP grammar are executed as
methods of class "parser".  Important public fields include 
globalSymTab, currSymTab, and curType.  These fields are used 
to store information to be transferred between different actions 
in CUP.  The "parser" class also contains main(), the starting
point of the user code.

<h3> expNode </h3>

     Stores information for individual instructions.  Basic unit
     of abstract syntax tree.  Contains a number of fields whose 
     contents vary depending on node type. 

<ul>
<li>
     Fields:

<ul>
<li> int nodeType; // type of the node: Const.INSTRUCTION, Const.IDENTIFIER, Const.INTEGER, Const.STRING, Const.ARRAY, Const.CALL

<li> int expType; // type of the variable: sym.INT, sym.VOID, sym.BOOL

<li> int val;               // value of integer constant

<li> String str;            // content of literal string

<li> symTabEntry  ident;     // pointer to the symbol table entry

<li> int opcode;             // opcode of the instruction
<li> expNode op1;            // operand 1
<li> expNode op2;            // operand 2
</ul>

<li>
     Node types:

<ul>
<li> Const.INTEGER //
	expType = sym.INT; 
	val = value
<li> Const.STRING  //
	expType = sym.VOID; 
	str = literal string
<li> Const.ARRAY  //
	expType = sym.INT; 
	op1 = array subscript
<li> Const.IDENTIFIER  //
	expType = sym.INT or sym.VOID; 
	ident = symTabEntry for identifier
<li> Const.CALL  //
	expType = sym.INT or sym.VOID; 
	op1 = name of function; 
	op2 = function argument (may be null)
<li> Const.INSTRUCTION  //
	expType = sym.INT, sym.VOID, or sym.BOOL; 
	opcode = code for instruction ;
	op1 = first operand ;
	op2 = 2nd operand 
</ul>
</ul>

<h3> astNode </h3>

     Node of the abstract syntax tree.  Contains a number of 
     fields whose contents vary depending on node type. 

<ul>
<li> Fields: 
<ul>
<li> int          treeType;       // type of the tree
<li> expNode      treeExp;        // useful for if, while, instructions 
<li> astNode      node1;          // useful for if and while 
<li> astNode      node2;          // useful for else 
<li> astNodeList  nlist;          // useful for block stmt 
</ul>

<li>
     Node types:
<ul>
<li> TREE_INSTR //
                treeType = Const.TREE_INSTR 
                expNode = instruction 

<li> TREE_IF //
                treeType = Const.TREE_IF
                treeExp = condition
                node1 = if block statement
                node2 = else block statement

<li> TREE_WHILE //
                treeType = Const.TREE_WHILE
                treeExp = condition
                node1 = loop body 

<li> TREE_BLK //
                treeType = Const.TREE_BLK
                nlist = list of block statements 

<li> TREE_PROC //
                treeType = Const.TREE_PROC
                treeExp = name of function
                node1 = block statement body
</ul>
</ul>

<h2>Submission</h2>

You can submit your project in two ways:

<ul> 
<li>
Submit your mycc.lex and mycc.cup files by
first putting both files in a single .zip or .jar archive.
The files should be at the top level of the archive,
not in a subdirectory.  
<p>
You may create a jar archive containing mycc.cup & mycc.lex 
by going to the directory containing your project, then either
execute goJar (or goJar.bat) or type the following command directly:
<p>

<center>
<tt>
jar cf p2.jar mycc.cup mycc.lex
</tt>
</center>
<p>

You can submit the resulting p2.jar archive to 
to the <a href="http://submit.cs.umd.edu/">submit server</a> 
by clicking on the submit link in the column "web submission".

<p>
<img src="submit1.jpg">
</p><p>
 
</p><p>
<img src="submit2.jpg">
</p><p>
 
Select the p2.jar archive using the "Browse" button,
then press the "Submit project!" button.
</p><p>
</p></li><li>

</li><li>
Submit directly by executing a Java program on a computer
with Java and network access.  Use the submit.jar file
from the archive <a href="http://www.cs.umd.edu/class/spring2011/cmsc430/p2/p2.zip">p2.zip</a>,
To submit, go to the directory containing your project, then either
execute goSubmit (or goSubmit.bat) or type the following command directly:
<p>

<center>
<tt>
java -jar submit.jar
</tt>
</center>
<p>

You will be asked to enter your class account and password, then
all files in the directory (and its subdirectories) will be
put in a jar file and submitted to the submit server.
If your submission is successful you will see the message:
</p><p>

</p><center>
<tt>
Successful submission #<submission_number> received for project 3
</submission_number></tt>
</center>
<p>

</p></li></ul>

<h2>Academic Integrity</h2>

<p>

</p><p>
Please <b>carefully read</b> the academic honesty section of the
course syllabus.  In particular, remember that you are not allowed
to show or copy any code for your project, either from the web or 
other students. <b>Any evidence</b> of impermissible cooperation on
projects, use of disallowed materials or resources, or unauthorized
use of computer accounts, <b>will be submitted</b> to the Student
Honor Council, which could result in an XF for the course, or
suspension or expulsion from the University.  Be sure you understand
what you are and what you are not permitted to do in regards to
academic integrity when it comes to project assignments.  These
policies apply to all students, and the Student Honor Council does not
consider lack of knowledge of the policies to be a defense for
violating them.  Full information is found in the course
syllabus---please review it at this time.


</p></td>
</tr></tbody></table>

</body></html>
